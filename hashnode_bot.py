import os
import sys
import requests
from datetime import datetime
import json

# --- R√©cup√©ration et v√©rification des cl√©s d'API ---
MISTRAL_API_KEY = os.getenv("MISTRAL_API_KEY")
HASHNODE_API_KEY = os.getenv("HASHNODE_API_KEY")

if not MISTRAL_API_KEY:
    print("‚ùå ERREUR : MISTRAL_API_KEY n'est pas d√©fini. Assurez-vous que la variable d'environnement est correctement pass√©e et que vous avez cr√©√© une cl√© API Mistral AI.")
    sys.exit(1)

if not HASHNODE_API_KEY:
    print("‚ùå ERREUR : HASHNODE_API_KEY n'est pas d√©fini. Assurez-vous que la variable d'environnement est correctement pass√©e.")
    sys.exit(1)

# --- D√©finit le mod√®le Mistral AI √† utiliser et l'URL de l'API ---
MISTRAL_MODEL_NAME = "mistral-tiny"
MISTRAL_API_BASE_URL = "https://api.mistral.ai/v1/chat/completions"

# --- Test d'authentification Mistral AI ---
def test_mistral_auth():
    headers = {
        "Authorization": f"Bearer {MISTRAL_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "model": MISTRAL_MODEL_NAME,
        "messages": [
            {
                "role": "user",
                "content": "Test de connexion."
            }
        ]
    }

    print(f"üîé Test d'authentification Mistral AI avec mod√®le '{MISTRAL_MODEL_NAME}' √† l'URL: {MISTRAL_API_BASE_URL}")
    try:
        resp = requests.post(MISTRAL_API_BASE_URL, headers=headers, json=payload, timeout=30)
        print(f"Auth test Mistral status: {resp.status_code}")
        print(f"Auth test Mistral response: {resp.text}")

        if resp.status_code == 200:
            print("‚úÖ Authentification Mistral AI r√©ussie et mod√®le accessible.")
            try:
                response_data = resp.json()
                if "choices" in response_data and response_data["choices"]:
                    print("‚úÖ R√©ponse du mod√®le au format attendu (contient 'choices').")
                else:
                    print("‚ö†Ô∏è R√©ponse du mod√®le valide mais ne contient pas 'choices' dans le format attendu.")
            except json.JSONDecodeError:
                print("‚ö†Ô∏è R√©ponse du mod√®le non JSON valide. Cela pourrait √™tre un probl√®me de serveur Mistral AI.")
        elif resp.status_code == 401:
            print("‚ùå √âchec de l‚Äôauthentification Mistral AI: 401 Unauthorized. Cl√© API incorrecte ou permissions insuffisantes.")
            sys.exit(1)
        else:
            print(f"‚ùå √âchec de l‚Äôauthentification Mistral AI. Statut inattendu: {resp.status_code}, R√©ponse: {resp.text}")
            sys.exit(1)
    except requests.exceptions.RequestException as e:
        print(f"‚ùå ERREUR r√©seau ou connexion lors du test d'authentification Mistral AI : {e}")
        sys.exit(1)

test_mistral_auth()

# --- G√©n√©ration de l'article via Mistral AI API ---
def generate_article():
    # Prompt simplifi√© pour le diagnostic
    article_prompt = "R√©dige un article de blog professionnel et d√©taill√© d'au moins 1500 mots en fran√ßais sur un sujet (d'actualit√© si possible) qui concerne l'informatique dans sa globalit√©. Signe par Nathan Remacle et optimise le SEO de l'article"
    
    headers = {
        "Authorization": f"Bearer {MISTRAL_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "model": MISTRAL_MODEL_NAME,
        "messages": [
            {
                "role": "user",
                "content": article_prompt
            }
        ],
        "temperature": 0.7,
        "max_tokens": 100000 # R√©duit les tokens pour un article plus court
    }

    print(f"\nüöÄ Tentative de g√©n√©ration d'article avec le mod√®le '{MISTRAL_MODEL_NAME}'...")
    try:
        response = requests.post(
            MISTRAL_API_BASE_URL,
            headers=headers,
            json=payload,
            timeout=120
        )
        response.raise_for_status()

        print("Status code Mistral:", response.status_code)
        print("Response Mistral:", response.text)

        data = response.json()
        
        if 'choices' in data and data['choices'] and 'message' in data['choices'][0] and 'content' in data['choices'][0]['message']:
            article_content = data['choices'][0]['message']['content'].strip()
            print("DEBUG: R√©ponse trait√©e comme Chat Completions API de Mistral AI.")
        else:
            raise ValueError(f"La r√©ponse de Mistral AI ne contient pas le format de chat completions attendu. R√©ponse compl√®te: {data}")
        
        return article_content
    except requests.exceptions.RequestException as e:
        print(f"‚ùå ERREUR HTTP lors de la g√©n√©ration de l'article avec Mistral AI : {e}")
        sys.exit(1)
    except ValueError as e:
        print(f"‚ùå ERREUR de donn√©es dans la r√©ponse Mistral AI : {e}")
        sys.exit(1)

# --- R√©cup√©ration de l'ID de la publication Hashnode ---
HASHNODE_API_URL = "https://gql.hashnode.com/"

def get_publication_id():
    query = """
    query {
      me {
        publications(first: 1) {
          edges {
            node {
              id
            }
          }
        }
      }
    }
    """
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {HASHNODE_API_KEY}"
    }
    print("\nüîé R√©cup√©ration de l'ID de publication Hashnode...")
    try:
        resp = requests.post(HASHNODE_API_URL, json={"query": query}, headers=headers)
        resp.raise_for_status()
        data = resp.json()
        
        if 'errors' in data:
            print(f"‚ùå ERREUR GraphQL de Hashnode lors de la r√©cup√©ration de l'ID de publication : {data['errors']}")
            sys.exit(1)

        if not data.get('data') or \
           not data['data'].get('me') or \
           not data['data']['me'].get('publications') or \
           not data['data']['me']['publications'].get('edges') or \
           not data['data']['me']['publications']['edges']:
            raise KeyError("Aucune publication trouv√©e ou chemin inattendu dans la r√©ponse Hashnode. V√©rifiez votre compte ou le sch√©ma de l'API.")
            
        publication_id = data['data']['me']['publications']['edges'][0]['node']['id']
        print(f"‚úÖ ID de publication Hashnode r√©cup√©r√© : {publication_id}")
        return publication_id
    except requests.exceptions.RequestException as e:
        print(f"‚ùå ERREUR HTTP lors de la r√©cup√©ration de l'ID de publication Hashnode : {e}")
        if 'resp' in locals() and resp is not None:
            print(f"R√©ponse Hashnode en cas d'erreur HTTP : {resp.text}")
        sys.exit(1)
    except KeyError as e:
        print(f"‚ùå ERREUR : Impossible de trouver l'ID de publication dans la r√©ponse Hashnode. D√©tails: {e}, R√©ponse: {resp.text if 'resp' in locals() else 'Pas de r√©ponse.'}")
        sys.exit(1)

# --- Publication de l'article sur Hashnode ---
def publish_article(content):
    publication_id = get_publication_id()
    title = "Article du " + datetime.now().strftime("%d %B %Y - %H:%M")

    mutation = """
    mutation PublishPost($input: PublishPostInput!) {
      publishPost(input: $input) {
        post {
          id
          title
          slug
          url
        }
      }
    }
    """
    variables = {
        "input": {
            "title": title,
            "contentMarkdown": content,
            "publicationId": publication_id,
            "tags": [],
            # "coverImageOptions": {"enabled": False}, # <<< COMMENT√â/SUPPRIM√â CETTE LIGNE
        }
    }

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {HASHNODE_API_KEY}"
    }

    print(f"\n‚úçÔ∏è Tentative de publication de l'article '{title}' sur Hashnode...")
    print(f"DEBUG: Payload JSON envoy√© √† Hashnode (sans le contenu d√©taill√©): {json.dumps(variables, indent=2)}")
    print(f"DEBUG: D√©but du contenu Markdown envoy√©: {content[:200]}...")

    try:
        resp = requests.post(HASHNODE_API_URL, json={"query": mutation, "variables": variables}, headers=headers)
        # NE PAS UTILISER resp.raise_for_status() ICI !
        # Car Hashnode renvoie 200 OK m√™me avec des erreurs GraphQL dans le payload.
        
        print("Publish status:", resp.status_code)
        print("Publish response:", resp.text)
        
        response_data = resp.json() # Parse la r√©ponse JSON

        # V√©rifier si la r√©ponse contient des erreurs GraphQL
        if 'errors' in response_data and response_data['errors']:
            print(f"‚ùå ERREUR GraphQL de Hashnode lors de la publication de l'article : {response_data['errors']}")
            sys.exit(1) # Quitte le script si une erreur GraphQL est trouv√©e

        post_url = None
        if 'data' in response_data and \
           'publishPost' in response_data['data'] and \
           'post' in response_data['data']['publishPost'] and \
           'url' in response_data['data']['publishPost']['post']:
            post_url = response_data['data']['publishPost']['post']['url']
            print(f"‚úÖ Article publi√© avec succ√®s : {title} √† l'URL : {post_url}")
        else:
            print(f"‚úÖ Article publi√© avec succ√®s (URL non r√©cup√©r√©e) : {title}")
            # Si pas d'erreur mais pas d'URL non plus, c'est peut-√™tre un succ√®s partiel ou un format inattendu
            # On pourrait envisager de sys.exit(1) ici aussi si l'URL est absolument n√©cessaire pour le succ√®s.

    except requests.exceptions.RequestException as e:
        print(f"‚ùå ERREUR HTTP lors de la publication de l'article sur Hashnode : {e}")
        print(f"R√©ponse Hashnode en cas d'erreur : {resp.text if 'resp' in locals() else 'Pas de r√©ponse.'}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Une erreur inattendue est survenue lors de la publication : {e}")
        sys.exit(1)

# --- Ex√©cution principale ---
if __name__ == "__main__":
    print("D√©marrage du bot Hashnode.")
    try:
        article = generate_article()
        publish_article(article)
        print("\nüéâ Bot Hashnode termin√© avec succ√®s !")
    except Exception as e:
        print(f"\nFATAL ERROR: Une erreur critique est survenue : {e}")
        sys.exit(1)